package currency

/*-------------------------------+
| Code generated by std_currency |
|          DO NOT EDIT           |
+-------------------------------*/

import "fmt"

// Currency defines a currency containing
// It's code, taken from the constants above
// as well as it's minor units, as an integer.
type Currency struct {
    code string
    minorUnits int
}

// Code returns the currency code to the user
func (c *Currency) Code() string { return c.code }
// MinorUnits returns the minor unit to the user
func (c *Currency) MinorUnits() int { return c.minorUnits }

// GetCurrency returns a currency struct if the provided
// code is contained within the valid codes. Otherwise
// an error will be returned
func GetCurrency(code string) (*Currency, error) {
    if Valid(code) {
        val, ok := currencies[code]
        if ok {
            return &val, nil
        }
    }
    return nil, fmt.Errorf("currency: could not find currency with code: %q", code)
}

// Valid checks if a provided code is contained
// inside the provided ValidCodes slice
func Valid(code string) bool {
    for _, c := range ValidCodes {
        if c == code {
            return true
        }
    }
    return false
}


var (
    {{ range $k, $v := . -}}
        // {{$v.Code}} currency struct
        {{$v.Code}} = Currency{ code: "{{$v.Code}}", minorUnits: {{$v.Units}} }
    {{ end }}
)

var currencies = map[string]Currency{
    {{ range $k, $v := . -}}
        "{{$v.Code}}": {{$v.Code}},
    {{ end }}
}

// ValidCodes is provided so that you may build your own validation against it
var ValidCodes = []string{
    {{ range $k, $v := . -}}
        "{{$v.Code}}",
    {{ end }}
}
